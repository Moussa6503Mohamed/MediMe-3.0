/**
 * @file firestore.rules
 * @description Firestore Security Rules for the MediMe Healthcare Platform.
 *
 * @version 1.0.0
 *
 * @section Core Philosophy
 * This ruleset enforces a strict, user-centric ownership model. The fundamental principle
 * is that users, whether they are patients or doctors, have exclusive control over their
 * own data. Access is granted based on the user's authenticated UID matching the ID in
 * the document path (e.g., /patients/{userId}).
 *
 * @section Data Structure
 * The data is organized into two primary top-level collections: `/patients` and `/doctors`.
 * All sensitive patient data, such as appointments, medications, and medical reports, is
 * stored in subcollections under the specific patient's document (e.g.,
 * /patients/{patientId}/appointments/{appointmentId}). This hierarchical structure
 * naturally isolates user data and simplifies security rules.
 *
 * @section Key Security Decisions
 * - **Default Deny:** All access is denied by default. Rules only grant permissions explicitly.
 * - **No Public Listing:** Listing the top-level `/patients` or `/doctors` collections is
 *   strictly forbidden to protect user privacy and prevent data enumeration attacks.
 * - **Strict Ownership:** A user can only access documents within their own data tree
 *   (e.g., a user with UID 'abc' can access /patients/abc but not /patients/xyz).
 * - **Collaborator Access:** For specific documents like Appointments, read and update
 *   access is granted to both the patient (owner) and the doctor associated with the
 *   appointment via a denormalized `doctorId` field on the document itself.
 * - **Prototyping Flexibility:** These rules prioritize authorization over schema validation.
 *   They do not enforce specific data types or field presence, allowing for rapid
 *   application development, except for fields critical to security (e.g., ownership IDs).
 *
 * @section Denormalization for Authorization
 * To ensure performant and secure access control, authorization-related data is denormalized. For
 * example, the `Appointment` document contains a `doctorId` field. This allows the rules
 * to grant the specified doctor access without needing slow and costly `get()` or `exists()`
 * calls to other collections.
 *
 * @section Structural Segregation
 * Patient and Doctor data are kept in separate top-level collections. Furthermore, all
 * patient-related data is nested within that patient's document tree. This clean separation
 * ensures that rules for one data type do not unintentionally affect another and makes
 * list operations on subcollections inherently secure.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // -------------------------------------------------------------------------
    // Helper Functions
    // -------------------------------------------------------------------------

    /**
     * @description Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user's UID matches the provided userId.
     * This is the core of the ownership model.
     * @param userId The UID to check against.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if a document currently exists.
     * Crucial for secure update and delete operations.
     */
    function isExistingDoc() {
      return resource != null;
    }

    /**
     * @description Checks if the authenticated user is an admin.
     * Admins have a custom claim 'admin' set to true.
     */
    function isAdmin() {
      return isSignedIn() && request.auth.token.admin == true;
    }

    /**
     * @description Checks if the authenticated user is a superadmin.
     * Superadmins have a custom claim 'role' set to 'superadmin'.
     */
    function isSuperAdmin() {
      return isAdmin() && request.auth.token.role == 'superadmin';
    }

    /**
     * @description Checks if the authenticated user has a specific permission.
     * @param permission The permission to check for.
     */
    function hasPermission(permission) {
      return isAdmin() && request.auth.token.permissions != null 
        && permission in request.auth.token.permissions;
    }

    /**
     * @description On create, validates that the document's internal `id` field
     * matches the user's auth UID, establishing a secure ownership link.
     * @param userId The document ID from the path, which must match the user's UID.
     */
    function isCreatingOwnProfile(userId) {
      return isOwner(userId) && request.resource.data.id == userId;
    }

    /**
     * @description On update, ensures the document's internal `id` field
     * cannot be changed, preventing ownership hijacking.
     */
    function isIdImmutable() {
      return request.resource.data.id == resource.data.id;
    }

    /**
     * @description On create, validates that a subcollection document's internal
     * `patientId` field matches the `patientId` from the document path.
     * @param patientId The patientId from the path.
     */
    function createdWithCorrectPatientId(patientId) {
      return request.resource.data.patientId == patientId;
    }

    /**
     * @description On update, ensures the `patientId` field on a subcollection
     * document is immutable.
     */
    function isPatientIdImmutable() {
      return request.resource.data.patientId == resource.data.patientId;
    }

    /**
     * @description Checks if the requesting user is the doctor assigned to the
     * appointment being accessed. Reads the `doctorId` from the existing document.
     */
    function isDoctorForAppointment() {
      return isSignedIn() && isExistingDoc() && request.auth.uid == resource.data.doctorId;
    }

    // -------------------------------------------------------------------------
    // Collection Rules
    // -------------------------------------------------------------------------

    /**
     * @description Patient Profile: Stores a patient's personal and medical information.
     * @path /patients/{patientId}
     * @allow (create) A new user can create their own patient profile.
     * @deny (create) A user cannot create a profile for another user.
     * @allow (read, update, delete) An authenticated user can manage their own profile.
     * @allow (read, update) Admins with 'manage_patients' permission can access patient profiles.
     * @deny (read, update, delete) A user cannot access another patient's profile.
     * @deny (list) Listing all patients is forbidden to protect privacy (except for admins).
     * @principle Restricts access to a user's own data tree (Self-Creation & Ownership).
     */
    match /patients/{patientId} {
      allow get: if isOwner(patientId) || hasPermission('manage_patients');
      allow list: if hasPermission('manage_patients');
      allow create: if isCreatingOwnProfile(patientId);
      allow update: if (isOwner(patientId) || hasPermission('manage_patients')) && isExistingDoc() && isIdImmutable();
      allow delete: if isOwner(patientId) && isExistingDoc();

      /**
       * @description Patient Appointments: Medical appointments for a patient.
       * @path /patients/{patientId}/appointments/{appointmentId}
       * @allow (read, update) The patient or the assigned doctor can view/update an appointment.
       * @allow (read, list, update) Admins with 'manage_appointments' permission can access appointments.
       * @deny (read, update) A user who is not the patient or assigned doctor cannot access it.
       * @allow (create, delete) Only the patient can create or delete their appointments.
       * @allow (list) The patient can list all of their own appointments.
       * @principle Enforces a shared access model between the patient and the doctor.
       */
      match /appointments/{appointmentId} {
        allow get: if isOwner(patientId) || isDoctorForAppointment() || hasPermission('manage_appointments');
        allow list: if isOwner(patientId) || hasPermission('manage_appointments');
        allow create: if isOwner(patientId) && createdWithCorrectPatientId(patientId);
        allow update: if (isOwner(patientId) || isDoctorForAppointment() || hasPermission('manage_appointments')) && isPatientIdImmutable() && request.resource.data.doctorId == resource.data.doctorId;
        allow delete: if isOwner(patientId) && isExistingDoc();
      }

      /**
       * @description Patient Medications: Prescribed medications for a patient.
       * @path /patients/{patientId}/medications/{medicationId}
       * @allow (all) Only the patient can CRUD their own medication records.
       * @deny (all) Another user cannot access a patient's medication list.
       * @principle Enforces strict data ownership. Access for other roles (e.g., doctors)
       *            is not possible without a denormalized ID field (e.g., 'prescriberId')
       *            on this document.
       */
      match /medications/{medicationId} {
        allow get, list, create, update, delete: if isOwner(patientId);
      }

      /**
       * @description Patient Medical Reports: Lab results and reports for a patient.
       * @path /patients/{patientId}/medicalReports/{medicalReportId}
       * @allow (all) Only the patient can CRUD their own medical reports.
       * @deny (all) Another user cannot access a patient's medical reports.
       * @principle Enforces strict data ownership. Access for other roles (e.g., doctors)
       *            is not possible without a denormalized ID field (eg 'orderingDoctorId')
       *            on this document
       */
      match /medicalReports/{medicalReportId} {
        allow get, list, create, update, delete: if isOwner(patientId);
      }
      
      /**
       * @description Family Members: Stores references to other patients in the family circle.
       * @path /patients/{patientId}/familyMembers/{familyMemberId}
       * @allow (all) Only the patient can manage their own family member list.
       * @deny (all) Another user cannot access or modify another patient's family list.
       * @principle Enforces strict data ownership for managing relationships.
       */
      match /familyMembers/{familyMemberId} {
          allow get, list, create, update, delete: if isOwner(patientId);
      }
    }

    /**
     * @description Doctor Profile: Stores a doctor's professional information.
     * @path /doctors/{doctorId}
     * @allow (create) A new user can create their own doctor profile.
     * @deny (create) A user cannot create a profile for another user.
     * @allow (read) Any authenticated user can view a doctor's profile.
     * @allow (list) Any authenticated user can list all doctors.
     * @allow (update, delete) An authenticated user can manage their own profile.
     * @allow (read, list, update) Admins with 'manage_doctors' permission can access doctor profiles.
     * @deny (read, update, delete) A user cannot access another doctor's profile.
     * @principle Publicly readable list, but write access restricted to owner.
     */
    match /doctors/{doctorId} {
      allow get, list: if isSignedIn();
      allow create: if isCreatingOwnProfile(doctorId);
      allow update: if (isOwner(doctorId) || hasPermission('manage_doctors')) && isExistingDoc() && isIdImmutable();
      allow delete: if isOwner(doctorId) && isExistingDoc();
    }

    /**
     * @description Admin Profile: Stores administrator information.
     * @path /admins/{adminId}
     * @allow (read, update) An admin can read and update their own profile.
     * @allow (read, list, create, update, delete) Superadmins or admins with 'manage_admins' can manage admin profiles.
     * @deny (all) Non-admins cannot access admin profiles.
     * @principle Admin-only access with role-based permissions.
     */
    match /admins/{adminId} {
      allow get: if isAdmin() && (isOwner(adminId) || hasPermission('manage_admins'));
      allow list: if hasPermission('manage_admins');
      allow create: if hasPermission('manage_admins');
      allow update: if isAdmin() && (isOwner(adminId) || hasPermission('manage_admins')) && isExistingDoc();
      allow delete: if hasPermission('manage_admins') && isExistingDoc();
    }

    /**
     * @description System Settings: Global system configuration.
     * @path /systemSettings/{document}
     * @allow (read) All authenticated admins can read system settings.
     * @allow (update) Only superadmins can update system settings.
     * @deny (all) Non-admins cannot access system settings.
     * @principle Superadmin-only write access.
     */
    match /systemSettings/{document} {
      allow get, list: if isAdmin();
      allow update: if isSuperAdmin();
      allow create, delete: if false; // System settings should be initialized only
    }

    /**
     * @description Audit Logs: Tracks all admin actions.
     * @path /auditLogs/{logId}
     * @allow (read, list) All authenticated admins can read audit logs.
     * @allow (create) Only Cloud Functions can create audit logs (enforced server-side).
     * @deny (update, delete) Audit logs are immutable.
     * @principle Read-only for admins, write-only for system.
     */
    match /auditLogs/{logId} {
      allow get, list: if isAdmin();
      allow create: if false; // Only Cloud Functions should create audit logs
      allow update, delete: if false; // Audit logs are immutable
    }
  }
}
